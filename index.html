<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>真實的麥塊世界</title>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 修復：將 perlin.js 作為傳統腳本載入，使其在全局範圍內可用 -->
    <script src="https://cdn.jsdelivr.net/npm/perlin.js/perlin.js"></script> 
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #2c2c2c;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        canvas {
            display: block;
        }
        .info-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2rem;
            max-width: 90%;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .controls {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
        }
        .control-item {
            display: flex;
            align-items: center;
        }
        .key {
            background-color: #555;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            margin-right: 8px;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 2px;
            background-color: white;
            border: 1px solid white;
            z-index: 999;
        }
        .controls-info {
            font-size: 1rem;
            margin-top: 15px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="info-box">
        <h2>真實的麥塊世界</h2>
        <div class="controls-info">
            <p>使用滑鼠點擊畫面開始遊玩。</p>
            <p><strong>WASD</strong>: 移動 &nbsp;&nbsp; <strong>滑鼠移動</strong>: 環顧四周</p>
            <p><strong>滑鼠左鍵</strong>: 破壞方塊 &nbsp;&nbsp; <strong>滑鼠右鍵</strong>: 放置方塊</p>
        </div>
    </div>
    <div class="crosshair"></div>

    <!-- 修復：移除 type="module" 讓 PerlinNoise 在全局作用域中可用 -->
    <script>
        // JavaScript 程式碼
        // 核心場景設定
        let scene, camera, renderer, controls;
        let isLocked = false;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let raycaster;
        const worldSize = 32;
        const blockHeight = 16;
        const blockMap = new Map();
        const blockType = 'grass';
        let intersected = null;
        let lastIntersected = null;

        // 方塊的材質顏色
        const materials = {
            'grass': new THREE.MeshLambertMaterial({ color: 0x6E8B3D }),
            'dirt': new THREE.MeshLambertMaterial({ color: 0x654321 }),
            'stone': new THREE.MeshLambertMaterial({ color: 0x808080 }),
            'sand': new THREE.MeshLambertMaterial({ color: 0xFADFAD })
        };
        const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
        let highlightBox;
        
        // 變數聲明：將 perlin 實例化延遲到 init() 函數中
        let perlin;

        // 初始化場景
        function init() {
            // 修復：在這裡初始化 Perlin Noise，確保外部腳本已載入
            perlin = new PerlinNoise();
            
            // 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 天空色

            // 相機
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(worldSize / 2, blockHeight + 2, worldSize / 2);

            // 渲染器
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 燈光
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // 環境光
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // 滑鼠控制
            controls = new THREE.Object3D();
            controls.rotation.order = 'YXZ'; // 確保 Y 軸先旋轉
            controls.add(camera);
            scene.add(controls);

            // Raycaster 用於偵測滑鼠點擊
            raycaster = new THREE.Raycaster();

            // 生成世界 (在 Perlin 初始化之後)
            generateWorld();

            // 偵測滑鼠點擊鎖定畫面
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });

            // 監聽 PointerLock 狀態
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);

            // 滑鼠與鍵盤事件監聽
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('resize', onWindowResize);
            window.addEventListener('resize', onWindowResize);
            
            // 創建高亮框
            highlightBox = new THREE.Mesh(new THREE.BoxGeometry(1.01, 1.01, 1.01), highlightMaterial);
            highlightBox.visible = false;
            scene.add(highlightBox);
            
            animate();
        }

        // 當 PointerLock 狀態改變時
        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                isLocked = true;
                document.querySelector('.info-box').style.display = 'none';
                document.querySelector('.crosshair').style.display = 'block';
            } else {
                isLocked = false;
                document.querySelector('.info-box').style.display = 'block';
                document.querySelector('.crosshair').style.display = 'none';
            }
        }

        function onPointerLockError() {
            console.error('PointerLock 錯誤');
        }

        // 滑鼠移動事件
        function onMouseMove(event) {
            if (isLocked) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                controls.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        // 鍵盤按下事件
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        }

        // 鍵盤放開事件
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        // 滑鼠點擊事件
        function onMouseDown(event) {
            if (!isLocked) return;

            // 滑鼠左鍵 (破壞方塊)
            if (event.button === 0 && intersected) {
                const pos = intersected.object.position;
                scene.remove(intersected.object);
                blockMap.delete(`${pos.x},${pos.y},${pos.z}`);
                intersected = null; // 清除被點擊的方塊
                highlightBox.visible = false;
            } 
            // 滑鼠右鍵 (放置方塊)
            else if (event.button === 2 && lastIntersected) {
                const normal = intersected.face.normal;
                const pos = intersected.object.position;

                const newPos = new THREE.Vector3(
                    pos.x + normal.x,
                    pos.y + normal.y,
                    pos.z + normal.z
                );

                if (!blockMap.has(`${newPos.x},${newPos.y},${newPos.z}`)) {
                    addBlock(newPos.x, newPos.y, newPos.z, blockType);
                }
            }
        }

        // 視窗大小改變時
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 生成地圖
        function generateWorld() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            
            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    const height = Math.floor(perlin.noise(x / 10, z / 10) * 10) + 5;
                    for (let y = 0; y < height; y++) {
                        let currentBlockType = 'dirt';
                        if (y === height - 1) {
                            currentBlockType = 'grass';
                        } else if (y < height - 2) {
                            currentBlockType = 'stone';
                        }
                        
                        addBlock(x, y, z, currentBlockType);
                    }
                }
            }
        }

        // 加入一個方塊
        function addBlock(x, y, z, type) {
            const material = materials[type];
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), material);
            mesh.position.set(x, y, z);
            mesh.userData.isBlock = true;
            mesh.userData.type = type;
            scene.add(mesh);
            blockMap.set(`${x},${y},${z}`, mesh);
        }

        // 動畫迴圈
        function animate() {
            requestAnimationFrame(animate);

            // 更新移動
            const velocity = new THREE.Vector3();
            if (isLocked) {
                if (moveForward) velocity.z -= 0.1;
                if (moveBackward) velocity.z += 0.1;
                if (moveLeft) velocity.x -= 0.1;
                if (moveRight) velocity.x += 0.1;

                controls.translateZ(velocity.z);
                controls.translateX(velocity.x);
            }

            // Raycasting 以偵測目標方塊
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            
            lastIntersected = intersected;
            intersected = null;

            if (intersects.length > 0) {
                const firstBlock = intersects.find(obj => obj.object.userData.isBlock);
                if (firstBlock) {
                    intersected = firstBlock;
                    highlightBox.position.copy(firstBlock.object.position);
                    highlightBox.visible = true;
                } else {
                    highlightBox.visible = false;
                }
            } else {
                highlightBox.visible = false;
            }

            renderer.render(scene, camera);
        }
        
        // 確保在視窗載入後再啟動
        window.onload = function() {
            init();
        };

    </script>
</body>
</html>